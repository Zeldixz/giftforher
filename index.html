<!DOCTYPE html>
<html lang="en">
<!--
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    JOSE'S QUEST: SAVING GABBY
    A Zelda-Style FNAF Adventure
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    Made with love for Gabby â¤ï¸
    
    HOW TO PLAY:
    - Desktop: Use WASD or Arrow Keys to move, SPACE to attack,
      SHIFT to dodge roll, E to interact/shield
    - Mobile: Use on-screen controls (D-Pad and action buttons)
    
    GAME FEATURES:
    âœ“ 5 Complete levels with unique themes and challenges
    âœ“ 5 Epic boss battles with multiple phases
    âœ“ 4 Different enemy types with intelligent AI
    âœ“ Emotional storyline with cutscenes
    âœ“ Save/Load system (auto-saves progress)
    âœ“ Cross-platform (Desktop & Mobile)
    âœ“ Full combat system with dodge rolling and items
    âœ“ Particle effects and screen shake
    âœ“ 8-bit style graphics and sound effects
    
    THE QUEST:
    Gabby has been taken by the animatronics! Guide Jose through
    the haunted pizzeria, defeat enemies, solve puzzles, battle
    fearsome bosses, and rescue the love of his life. A journey
    of courage, determination, and true love awaits!
    
    To Gabby: The Zelda to my Link. Love always, Jose ðŸ’
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Jose's Quest: Saving Gabby</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            touch-action: none;
            position: fixed;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #1a1a2e;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // ===================================
        // JOSE'S QUEST: SAVING GABBY
        // A Zelda-Style FNAF Adventure
        // Made with love for Gabby â¤ï¸
        // ===================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game configuration
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const TILE_SIZE = 16;
        const FPS = 60;
        const FRAME_TIME = 1000 / FPS;

        // Screen shake
        let screenShake = 0;
        let shakeX = 0;
        let shakeY = 0;

        function addScreenShake(intensity = 10) {
            screenShake = intensity;
        }

        // Responsive canvas setup
        function resizeCanvas() {
            const aspectRatio = GAME_WIDTH / GAME_HEIGHT;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowRatio = windowWidth / windowHeight;

            if (windowRatio > aspectRatio) {
                canvas.height = windowHeight;
                canvas.width = windowHeight * aspectRatio;
            } else {
                canvas.width = windowWidth;
                canvas.height = windowWidth / aspectRatio;
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ===================================
        // INPUT SYSTEM
        // ===================================

        const Input = {
            keys: {},
            prevKeys: {},
            debugText: '',
            
            init() {
                // Initialize all keys to false to prevent undefined issues
                const allKeys = ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 
                                 ' ', 'enter', 'shift', 'e', 'escape'];
                allKeys.forEach(key => {
                    this.keys[key] = false;
                    this.prevKeys[key] = false;
                });
                
                // Keyboard events - simple and direct
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    this.keys[key] = true;
                    this.debugText = `Key: ${e.key} (${key})`;
                    console.log('KEY DOWN:', e.key, '/', key);
                    
                    // Prevent default for game keys
                    if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd', 'enter'].includes(key)) {
                        e.preventDefault();
                    }
                }, false);

                document.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    this.keys[key] = false;
                }, false);
                
                console.log('âœ“ Input system initialized!');
                console.log('âœ“ Try pressing SPACE, ENTER, or ARROW keys');
            },

            update() {
                // Copy current state to previous (create new object to avoid reference issues)
                this.prevKeys = Object.assign({}, this.keys);
            },

            isDown(action) {
                switch(action) {
                    case 'up':
                        return !!(this.keys['w'] || this.keys['arrowup']);
                    case 'down':
                        return !!(this.keys['s'] || this.keys['arrowdown']);
                    case 'left':
                        return !!(this.keys['a'] || this.keys['arrowleft']);
                    case 'right':
                        return !!(this.keys['d'] || this.keys['arrowright']);
                    case 'attack':
                        return !!(this.keys[' '] || this.keys['enter']);
                    case 'dodge':
                        return !!this.keys['shift'];
                    case 'interact':
                        return !!(this.keys['e'] || this.keys['enter']);
                    case 'pause':
                        return !!this.keys['escape'];
                    default:
                        return false;
                }
            },

            wasDown(action) {
                switch(action) {
                    case 'up':
                        return !!(this.prevKeys['w'] || this.prevKeys['arrowup']);
                    case 'down':
                        return !!(this.prevKeys['s'] || this.prevKeys['arrowdown']);
                    case 'left':
                        return !!(this.prevKeys['a'] || this.prevKeys['arrowleft']);
                    case 'right':
                        return !!(this.prevKeys['d'] || this.prevKeys['arrowright']);
                    case 'attack':
                        return !!(this.prevKeys[' '] || this.prevKeys['enter']);
                    case 'dodge':
                        return !!this.prevKeys['shift'];
                    case 'interact':
                        return !!(this.prevKeys['e'] || this.prevKeys['enter']);
                    case 'pause':
                        return !!this.prevKeys['escape'];
                    default:
                        return false;
                }
            },

            justPressed(action) {
                const isCurrentlyDown = this.isDown(action);
                const wasPreviouslyDown = this.wasDown(action);
                return isCurrentlyDown && !wasPreviouslyDown;
            }
        };

        // ===================================
        // SAVE/LOAD SYSTEM
        // ===================================

        const SaveSystem = {
            save(player, currentLevel) {
                const saveData = {
                    level: currentLevel,
                    health: player.health,
                    maxHealth: player.maxHealth,
                    keys: player.keys,
                    hasBoots: player.hasBoots,
                    hasShield: player.hasShield,
                    hasFlashlight: player.hasFlashlight,
                    arrows: player.arrows,
                    timestamp: Date.now()
                };
                localStorage.setItem('josesquest_save', JSON.stringify(saveData));
            },

            load() {
                const saveData = localStorage.getItem('josesquest_save');
                if (saveData) {
                    return JSON.parse(saveData);
                }
                return null;
            },

            hasSave() {
                return localStorage.getItem('josesquest_save') !== null;
            },

            deleteSave() {
                localStorage.removeItem('josesquest_save');
            }
        };

        // ===================================
        // AUDIO SYSTEM
        // ===================================

        const Audio = {
            context: null,
            sounds: {},
            music: {},
            currentMusic: null,

            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.warn('Web Audio API not supported');
                }
            },

            playSound(name) {
                if (!this.context) return;
                // Sound effects will be generated procedurally
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                switch(name) {
                    case 'sword':
                        oscillator.frequency.value = 200;
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.1);
                        break;
                    case 'hit':
                        oscillator.frequency.value = 100;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.2);
                        break;
                    case 'pickup':
                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.context.currentTime + 0.3);
                        break;
                }
            },

            playMusic(name) {
                // Music will be simple looping tones for now
                if (this.currentMusic === name) return;
                this.currentMusic = name;
            },

            stopMusic() {
                this.currentMusic = null;
            }
        };

        // ===================================
        // SPRITE SYSTEM
        // ===================================

        const Sprites = {
            cache: {},

            create(width, height, drawFn) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                drawFn(ctx);
                return canvas;
            },

            // Jose sprite (Link-style hero)
            createJose() {
                return {
                    down: [
                        this.create(16, 16, (ctx) => {
                            // Head (brown hair)
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 2, 8, 4);
                            // Face
                            ctx.fillStyle = '#FFD4A3';
                            ctx.fillRect(5, 4, 6, 4);
                            // Eyes
                            ctx.fillStyle = '#000';
                            ctx.fillRect(6, 5, 1, 1);
                            ctx.fillRect(9, 5, 1, 1);
                            // Green tunic
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(4, 8, 8, 6);
                            // Belt
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 10, 8, 1);
                            // Legs
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(5, 14, 2, 2);
                            ctx.fillRect(9, 14, 2, 2);
                        }),
                        this.create(16, 16, (ctx) => {
                            // Frame 2 (walking)
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 2, 8, 4);
                            ctx.fillStyle = '#FFD4A3';
                            ctx.fillRect(5, 4, 6, 4);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(6, 5, 1, 1);
                            ctx.fillRect(9, 5, 1, 1);
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(4, 8, 8, 6);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 10, 8, 1);
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(4, 14, 2, 2);
                            ctx.fillRect(10, 14, 2, 2);
                        })
                    ],
                    up: [
                        this.create(16, 16, (ctx) => {
                            // Back of head
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 2, 8, 6);
                            // Green tunic
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(4, 8, 8, 6);
                            // Belt
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 10, 8, 1);
                            // Legs
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(5, 14, 2, 2);
                            ctx.fillRect(9, 14, 2, 2);
                        }),
                        this.create(16, 16, (ctx) => {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 2, 8, 6);
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(4, 8, 8, 6);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(4, 10, 8, 1);
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(4, 14, 2, 2);
                            ctx.fillRect(10, 14, 2, 2);
                        })
                    ],
                    left: [
                        this.create(16, 16, (ctx) => {
                            // Side view
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 2, 6, 4);
                            ctx.fillStyle = '#FFD4A3';
                            ctx.fillRect(6, 4, 5, 4);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(7, 5, 1, 1);
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(5, 8, 6, 6);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 10, 6, 1);
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(6, 14, 2, 2);
                        }),
                        this.create(16, 16, (ctx) => {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 2, 6, 4);
                            ctx.fillStyle = '#FFD4A3';
                            ctx.fillRect(6, 4, 5, 4);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(7, 5, 1, 1);
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(5, 8, 6, 6);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 10, 6, 1);
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(7, 14, 2, 2);
                        })
                    ],
                    right: [
                        this.create(16, 16, (ctx) => {
                            // Side view (mirrored)
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 2, 6, 4);
                            ctx.fillStyle = '#FFD4A3';
                            ctx.fillRect(5, 4, 5, 4);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(8, 5, 1, 1);
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(5, 8, 6, 6);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 10, 6, 1);
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(8, 14, 2, 2);
                        }),
                        this.create(16, 16, (ctx) => {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 2, 6, 4);
                            ctx.fillStyle = '#FFD4A3';
                            ctx.fillRect(5, 4, 5, 4);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(8, 5, 1, 1);
                            ctx.fillStyle = '#2D8B2D';
                            ctx.fillRect(5, 8, 6, 6);
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(5, 10, 6, 1);
                            ctx.fillStyle = '#1a5c1a';
                            ctx.fillRect(6, 14, 2, 2);
                        })
                    ]
                };
            },

            // Gabby sprite (for cutscenes)
            createGabby() {
                return this.create(16, 16, (ctx) => {
                    // Blonde hair
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(4, 2, 8, 4);
                    // Face
                    ctx.fillStyle = '#FFD4A3';
                    ctx.fillRect(5, 4, 6, 4);
                    // Eyes
                    ctx.fillStyle = '#4169E1';
                    ctx.fillRect(6, 5, 1, 1);
                    ctx.fillRect(9, 5, 1, 1);
                    // Smile
                    ctx.fillStyle = '#000';
                    ctx.fillRect(6, 7, 4, 1);
                    // Blue dress
                    ctx.fillStyle = '#4169E1';
                    ctx.fillRect(4, 8, 8, 8);
                });
            },

            // Basic animatronic enemy
            createBasicAnimatronic() {
                return this.create(16, 16, (ctx) => {
                    // Body (gray/brown)
                    ctx.fillStyle = '#555';
                    ctx.fillRect(4, 4, 8, 10);
                    // Eyes (glowing red)
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(5, 6, 2, 2);
                    ctx.fillRect(9, 6, 2, 2);
                    // Teeth
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(6, 10, 1, 2);
                    ctx.fillRect(8, 10, 1, 2);
                    // Ears
                    ctx.fillStyle = '#555';
                    ctx.fillRect(3, 3, 2, 3);
                    ctx.fillRect(11, 3, 2, 3);
                });
            },

            // Heart container
            createHeart(empty = false) {
                return this.create(16, 16, (ctx) => {
                    ctx.fillStyle = empty ? '#444' : '#FF0000';
                    // Heart shape
                    ctx.fillRect(3, 4, 4, 2);
                    ctx.fillRect(9, 4, 4, 2);
                    ctx.fillRect(2, 6, 12, 4);
                    ctx.fillRect(3, 10, 10, 2);
                    ctx.fillRect(5, 12, 6, 2);
                    ctx.fillRect(6, 14, 4, 1);
                });
            },

            // Key item
            createKey() {
                return this.create(16, 16, (ctx) => {
                    ctx.fillStyle = '#FFD700';
                    // Key head
                    ctx.fillRect(6, 4, 4, 4);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(7, 5, 2, 2);
                    ctx.fillStyle = '#FFD700';
                    // Key shaft
                    ctx.fillRect(7, 8, 2, 6);
                    // Key teeth
                    ctx.fillRect(9, 12, 2, 2);
                });
            }
        };

        // Initialize sprites
        Sprites.jose = Sprites.createJose();
        Sprites.gabby = Sprites.createGabby();
        Sprites.basicEnemy = Sprites.createBasicAnimatronic();
        Sprites.heart = Sprites.createHeart(false);
        Sprites.heartEmpty = Sprites.createHeart(true);
        Sprites.key = Sprites.createKey();

        // ===================================
        // PARTICLE SYSTEM
        // ===================================

        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
            }

            update(dt) {
                this.x += this.vx * dt / 16;
                this.y += this.vy * dt / 16;
                this.life -= dt;
                return this.life > 0;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(this.x, this.y, 2, 2);
                ctx.globalAlpha = 1;
            }
        }

        const ParticleSystem = {
            particles: [],

            createExplosion(x, y, color = '#FFA500') {
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = 2 + Math.random() * 2;
                    this.particles.push(new Particle(
                        x, y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color,
                        500
                    ));
                }
            },

            createSlash(x, y, direction) {
                const color = '#ADD8E6';
                for (let i = 0; i < 10; i++) {
                    let vx = 0, vy = 0;
                    switch(direction) {
                        case 'up': vy = -2 - Math.random(); break;
                        case 'down': vy = 2 + Math.random(); break;
                        case 'left': vx = -2 - Math.random(); break;
                        case 'right': vx = 2 + Math.random(); break;
                    }
                    this.particles.push(new Particle(
                        x + (Math.random() - 0.5) * 10,
                        y + (Math.random() - 0.5) * 10,
                        vx, vy, color, 300
                    ));
                }
            },

            createHeal(x, y) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push(new Particle(
                        x + (Math.random() - 0.5) * 10,
                        y + (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 2,
                        -2 - Math.random() * 2,
                        '#00FF00',
                        600
                    ));
                }
            },

            update(dt) {
                this.particles = this.particles.filter(p => p.update(dt));
            },

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
            }
        };

        // ===================================
        // GAME STATE MANAGER
        // ===================================

        const GameState = {
            current: 'MENU',
            states: {},

            setState(newState) {
                if (this.states[this.current] && this.states[this.current].exit) {
                    this.states[this.current].exit();
                }
                this.current = newState;
                if (this.states[this.current] && this.states[this.current].enter) {
                    this.states[this.current].enter();
                }
            },

            update(dt) {
                if (this.states[this.current] && this.states[this.current].update) {
                    this.states[this.current].update(dt);
                }
            },

            draw(ctx) {
                if (this.states[this.current] && this.states[this.current].draw) {
                    this.states[this.current].draw(ctx);
                }
            }
        };

        // ===================================
        // PLAYER CLASS
        // ===================================

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.speed = 2;
                this.direction = 'down';
                this.frame = 0;
                this.frameTimer = 0;
                this.health = 6;
                this.maxHealth = 6;
                this.attacking = false;
                this.attackTimer = 0;
                this.attackCooldown = 0;
                this.dodging = false;
                this.dodgeTimer = 0;
                this.dodgeCooldown = 0;
                this.invincible = false;
                this.invincibleTimer = 0;
                this.comboCount = 0;
                this.keys = 0;
                this.hasBoots = false;
                this.hasShield = false;
                this.hasFlashlight = false;
                this.arrows = 0;
                this.blocking = false;
            }

            update(dt) {
                // Update timers
                this.frameTimer += dt;
                if (this.frameTimer >= 200) {
                    this.frame = (this.frame + 1) % 2;
                    this.frameTimer = 0;
                }

                if (this.attackTimer > 0) this.attackTimer -= dt;
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.dodgeTimer > 0) this.dodgeTimer -= dt;
                if (this.dodgeCooldown > 0) this.dodgeCooldown -= dt;
                if (this.invincibleTimer > 0) this.invincibleTimer -= dt;

                this.attacking = this.attackTimer > 0;
                this.dodging = this.dodgeTimer > 0;
                this.invincible = this.invincibleTimer > 0 || this.dodging;

                // Movement
                if (!this.attacking && !this.dodging) {
                    let dx = 0, dy = 0;

                    if (Input.isDown('up')) {
                        dy -= 1;
                        this.direction = 'up';
                    }
                    if (Input.isDown('down')) {
                        dy += 1;
                        this.direction = 'down';
                    }
                    if (Input.isDown('left')) {
                        dx -= 1;
                        this.direction = 'left';
                    }
                    if (Input.isDown('right')) {
                        dx += 1;
                        this.direction = 'right';
                    }

                    // Normalize diagonal movement
                    if (dx !== 0 && dy !== 0) {
                        dx *= 0.707;
                        dy *= 0.707;
                    }

                    this.x += dx * this.speed * (dt / 16);
                    this.y += dy * this.speed * (dt / 16);

                    // Keep player in bounds
                    this.x = Math.max(0, Math.min(GAME_WIDTH - this.width, this.x));
                    this.y = Math.max(0, Math.min(GAME_HEIGHT - this.height, this.y));
                }

                // Dodge roll
                if (Input.isDown('dodge') && this.dodgeCooldown <= 0 && !this.attacking) {
                    this.dodgeTimer = 300; // 0.3s
                    this.dodgeCooldown = 1000; // 1s cooldown
                    this.invincibleTimer = 300; // i-frames

                    // Move in direction
                    let dx = 0, dy = 0;
                    switch(this.direction) {
                        case 'up': dy = -1; break;
                        case 'down': dy = 1; break;
                        case 'left': dx = -1; break;
                        case 'right': dx = 1; break;
                    }
                    this.x += dx * 30;
                    this.y += dy * 30;

                    // Keep in bounds
                    this.x = Math.max(0, Math.min(GAME_WIDTH - this.width, this.x));
                    this.y = Math.max(0, Math.min(GAME_HEIGHT - this.height, this.y));
                }

                // Attack
                if (Input.isDown('attack') && this.attackCooldown <= 0 && !this.dodging) {
                    this.attackTimer = 200;
                    this.attackCooldown = 500; // 0.5s between attacks
                    this.attacking = true;
                    this.comboCount = (this.comboCount + 1) % 3;
                    
                    Audio.playSound('sword');
                    ParticleSystem.createSlash(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        this.direction
                    );
                }

                // Blocking (shield)
                this.blocking = this.hasShield && Input.isDown('interact') && !this.attacking && !this.dodging;
            }

            takeDamage(amount) {
                if (this.invincible) return false;

                if (this.blocking) {
                    amount = Math.floor(amount / 2);
                }

                this.health -= amount;
                this.invincibleTimer = 1000; // 1s invincibility after hit
                
                Audio.playSound('hit');
                addScreenShake(15);
                
                // Vibration feedback
                if (navigator.vibrate) {
                    navigator.vibrate(200);
                }

                if (this.health <= 0) {
                    this.health = 0;
                    // Game over - restart level
                    setTimeout(() => {
                        const currentState = GameState.current;
                        GameState.setState(currentState);
                    }, 1000);
                }

                return true;
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                Audio.playSound('pickup');
                ParticleSystem.createHeal(this.x + this.width / 2, this.y + this.height / 2);
            }

            getAttackBox() {
                if (!this.attacking) return null;

                const reach = 20;
                let box = { x: this.x, y: this.y, width: this.width, height: this.height };

                switch(this.direction) {
                    case 'up':
                        box.y -= reach;
                        box.height += reach;
                        break;
                    case 'down':
                        box.height += reach;
                        break;
                    case 'left':
                        box.x -= reach;
                        box.width += reach;
                        break;
                    case 'right':
                        box.width += reach;
                        break;
                }

                return box;
            }

            draw(ctx) {
                const sprite = Sprites.jose[this.direction][this.frame];
                
                // Flash when invincible
                if (this.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                ctx.drawImage(sprite, this.x, this.y);
                ctx.globalAlpha = 1;

                // Draw shield if blocking
                if (this.blocking) {
                    ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
                    ctx.fillRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                }
            }
        }

        // ===================================
        // ENEMY BASE CLASS
        // ===================================

        class Enemy {
            constructor(x, y, health, speed, type = 'basic') {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.health = health;
                this.maxHealth = health;
                this.speed = speed;
                this.type = type;
                this.state = 'patrol';
                this.stateTimer = 0;
                this.attackCooldown = 0;
                this.direction = 'down';
                this.patrolPoints = [];
                this.currentPatrolIndex = 0;
                this.knockbackX = 0;
                this.knockbackY = 0;
                this.projectiles = [];
            }

            update(dt, player) {
                this.stateTimer -= dt;
                this.attackCooldown -= dt;

                // Apply knockback
                this.x += this.knockbackX;
                this.y += this.knockbackY;
                this.knockbackX *= 0.8;
                this.knockbackY *= 0.8;

                // Distance to player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Type-specific behavior
                if (this.type === 'chef') {
                    this.updateChef(dt, player, dx, dy, dist);
                } else if (this.type === 'arcade') {
                    this.updateArcade(dt, player, dx, dy, dist);
                } else if (this.type === 'shadow') {
                    this.updateShadow(dt, player, dx, dy, dist);
                } else {
                    this.updateBasic(dt, player, dx, dy, dist);
                }

                // Update projectiles
                this.projectiles = this.projectiles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= dt;
                    
                    // Check collision with player
                    if (p.checkCollision(player) && !player.invincible) {
                        player.takeDamage(1);
                        return false;
                    }
                    
                    return p.life > 0 && p.x > 0 && p.x < GAME_WIDTH && p.y > 0 && p.y < GAME_HEIGHT;
                });
            }

            updateBasic(dt, player, dx, dy, dist) {
                // State machine
                if (dist < 5 * TILE_SIZE && this.state !== 'attacking') {
                    this.state = 'chasing';
                }

                if (this.state === 'chasing') {
                    // Move toward player
                    const angle = Math.atan2(dy, dx);
                    this.x += Math.cos(angle) * this.speed * (dt / 16);
                    this.y += Math.sin(angle) * this.speed * (dt / 16);

                    // Update direction
                    if (Math.abs(dx) > Math.abs(dy)) {
                        this.direction = dx > 0 ? 'right' : 'left';
                    } else {
                        this.direction = dy > 0 ? 'down' : 'up';
                    }

                    // Attack if close enough
                    if (dist < TILE_SIZE * 1.5 && this.attackCooldown <= 0) {
                        this.attack(player);
                    }
                } else if (this.state === 'patrol') {
                    this.patrol(dt);
                }
            }

            updateChef(dt, player, dx, dy, dist) {
                if (dist < 6 * TILE_SIZE) {
                    this.state = 'chasing';
                }

                if (this.state === 'chasing') {
                    // Move toward player
                    const angle = Math.atan2(dy, dx);
                    this.x += Math.cos(angle) * this.speed * (dt / 16);
                    this.y += Math.sin(angle) * this.speed * (dt / 16);

                    // Throw projectile at range
                    if (dist > TILE_SIZE * 2 && dist < TILE_SIZE * 5 && this.attackCooldown <= 0) {
                        this.throwProjectile(dx, dy, dist);
                        this.attackCooldown = 1500;
                    }

                    // Retreat if too close and damaged
                    if (dist < TILE_SIZE * 2 && this.health < this.maxHealth) {
                        this.x -= Math.cos(angle) * this.speed * 2 * (dt / 16);
                        this.y -= Math.sin(angle) * this.speed * 2 * (dt / 16);
                    }
                } else {
                    this.patrol(dt);
                }
            }

            updateArcade(dt, player, dx, dy, dist) {
                if (dist < 7 * TILE_SIZE) {
                    this.state = 'chasing';
                }

                if (this.state === 'chasing') {
                    // Zig-zag movement
                    const angle = Math.atan2(dy, dx) + Math.sin(Date.now() / 200) * 0.5;
                    this.x += Math.cos(angle) * this.speed * 1.2 * (dt / 16);
                    this.y += Math.sin(angle) * this.speed * 1.2 * (dt / 16);

                    // Quick dash attack
                    if (dist < TILE_SIZE * 3 && this.attackCooldown <= 0) {
                        this.dash(dx, dy, dist);
                        this.attackCooldown = 2000;
                    }
                }
            }

            updateShadow(dt, player, dx, dy, dist) {
                // Invisible until close
                this.visible = dist < TILE_SIZE * 2 || (player.hasFlashlight && dist < TILE_SIZE * 4);

                if (this.visible && dist < 6 * TILE_SIZE) {
                    // Ambush from behind
                    const behindPlayer = this.isBehindPlayer(player);
                    if (behindPlayer && dist > TILE_SIZE) {
                        const angle = Math.atan2(dy, dx);
                        this.x += Math.cos(angle) * this.speed * 1.3 * (dt / 16);
                        this.y += Math.sin(angle) * this.speed * 1.3 * (dt / 16);
                    } else if (dist < TILE_SIZE * 1.5 && this.attackCooldown <= 0) {
                        this.attack(player);
                    }

                    // Run away if flashlight used
                    if (player.hasFlashlight && Input.isDown('interact')) {
                        const angle = Math.atan2(dy, dx);
                        this.x -= Math.cos(angle) * this.speed * 3 * (dt / 16);
                        this.y -= Math.sin(angle) * this.speed * 3 * (dt / 16);
                    }
                } else {
                    this.patrol(dt);
                }
            }

            patrol(dt) {
                if (this.patrolPoints.length > 0) {
                    const target = this.patrolPoints[this.currentPatrolIndex];
                    const tdx = target.x - this.x;
                    const tdy = target.y - this.y;
                    const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                    if (tdist < 5) {
                        this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
                    } else {
                        const angle = Math.atan2(tdy, tdx);
                        this.x += Math.cos(angle) * this.speed * 0.5 * (dt / 16);
                        this.y += Math.sin(angle) * this.speed * 0.5 * (dt / 16);
                    }
                }
            }

            throwProjectile(dx, dy, dist) {
                const angle = Math.atan2(dy, dx);
                this.projectiles.push({
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 2000,
                    checkCollision(other) {
                        return this.x > other.x && this.x < other.x + other.width &&
                               this.y > other.y && this.y < other.y + other.height;
                    }
                });
            }

            dash(dx, dy, dist) {
                const angle = Math.atan2(dy, dx);
                this.knockbackX = Math.cos(angle) * 15;
                this.knockbackY = Math.sin(angle) * 15;
            }

            isBehindPlayer(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                switch(player.direction) {
                    case 'up': return dy < 0;
                    case 'down': return dy > 0;
                    case 'left': return dx < 0;
                    case 'right': return dx > 0;
                }
                return false;
            }

            attack(player) {
                this.attackCooldown = 2000; // 2s between attacks
                if (this.checkCollision(player)) {
                    player.takeDamage(1);
                }
            }

            takeDamage(amount, fromX, fromY) {
                this.health -= amount;
                
                // Knockback
                const angle = Math.atan2(this.y - fromY, this.x - fromX);
                this.knockbackX = Math.cos(angle) * 5;
                this.knockbackY = Math.sin(angle) * 5;

                Audio.playSound('hit');

                // Arcade bots teleport when hit
                if (this.type === 'arcade' && Math.random() < 0.3) {
                    ParticleSystem.createExplosion(this.x, this.y, '#00FFFF');
                    this.x = Math.random() * (GAME_WIDTH - this.width);
                    this.y = Math.random() * (GAME_HEIGHT - this.height);
                    ParticleSystem.createExplosion(this.x, this.y, '#00FFFF');
                }

                if (this.health <= 0) {
                    ParticleSystem.createExplosion(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        '#FF4500'
                    );
                    return true; // Enemy defeated
                }
                return false;
            }

            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }

            draw(ctx) {
                // Don't draw if invisible (shadow type)
                if (this.type === 'shadow' && !this.visible) {
                    // Show slight shimmer
                    if (Math.floor(Date.now() / 200) % 2 === 0) {
                        ctx.globalAlpha = 0.2;
                    } else {
                        return;
                    }
                }

                // Health bar
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x, this.y - 6, this.width, 2);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(this.x, this.y - 6, this.width * (this.health / this.maxHealth), 2);

                // Enemy sprite (different colors by type)
                let sprite = Sprites.basicEnemy;
                ctx.drawImage(sprite, this.x, this.y);

                // Type visual indicators
                if (this.type === 'chef') {
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(this.x + 6, this.y, 4, 2);
                } else if (this.type === 'arcade') {
                    ctx.fillStyle = '#00FFFF';
                    ctx.fillRect(this.x + 2, this.y + 2, 2, 2);
                    ctx.fillRect(this.x + 12, this.y + 2, 2, 2);
                } else if (this.type === 'shadow') {
                    ctx.fillStyle = '#800080';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }

                ctx.globalAlpha = 1;

                // Draw projectiles
                ctx.fillStyle = '#FF6347';
                this.projectiles.forEach(p => {
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                });
            }
        }

        // ===================================
        // BOSS CLASS
        // ===================================

        class Boss extends Enemy {
            constructor(x, y, health, name, type) {
                super(x, y, health, 1.5, 'boss');
                this.name = name;
                this.bossType = type;
                this.phase = 1;
                this.width = 32;
                this.height = 32;
                this.attackPattern = 0;
                this.patternTimer = 0;
                this.minions = [];
            }

            update(dt, player) {
                this.patternTimer += dt;
                this.attackCooldown -= dt;

                // Apply knockback
                this.x += this.knockbackX;
                this.y += this.knockbackY;
                this.knockbackX *= 0.9;
                this.knockbackY *= 0.9;

                // Phase transitions
                const healthPercent = this.health / this.maxHealth;
                if (this.bossType === 'golden-freddy') {
                    if (healthPercent <= 0.33 && this.phase < 3) {
                        this.phase = 3;
                        this.speed = 2.5;
                    } else if (healthPercent <= 0.66 && this.phase < 2) {
                        this.phase = 2;
                        this.spawnMinions(4);
                    }
                } else if (this.bossType === 'chica') {
                    if (healthPercent <= 0.5 && this.minions.length === 0) {
                        this.spawnMinions(2);
                    }
                } else if (this.bossType === 'bonnie') {
                    if (healthPercent <= 0.25) {
                        this.speed = 2.5; // Enrage mode
                    }
                }

                // Boss-specific behavior
                switch(this.bossType) {
                    case 'chica':
                        this.updateChicaBehavior(dt, player);
                        break;
                    case 'foxy':
                        this.updateFoxyBehavior(dt, player);
                        break;
                    case 'twins':
                        this.updateTwinsBehavior(dt, player);
                        break;
                    case 'bonnie':
                        this.updateBonnieBehavior(dt, player);
                        break;
                    case 'golden-freddy':
                        this.updateGoldenFreddyBehavior(dt, player);
                        break;
                }

                // Update minions
                this.minions = this.minions.filter(m => {
                    m.update(dt, player);
                    const attackBox = player.getAttackBox();
                    if (attackBox && m.checkCollision(attackBox)) {
                        return !m.takeDamage(1, player.x, player.y);
                    }
                    return true;
                });

                // Update projectiles
                this.projectiles = this.projectiles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= dt;
                    if (p.checkCollision(player) && !player.invincible) {
                        player.takeDamage(1);
                        return false;
                    }
                    return p.life > 0 && p.x > -50 && p.x < GAME_WIDTH + 50 && p.y > -50 && p.y < GAME_HEIGHT + 50;
                });
            }

            updateChicaBehavior(dt, player) {
                // Circular movement
                const centerX = GAME_WIDTH / 2;
                const centerY = GAME_HEIGHT / 2;
                const angle = (this.patternTimer / 2000) * Math.PI * 2;
                const radius = 150;
                this.x = centerX + Math.cos(angle) * radius - this.width / 2;
                this.y = centerY + Math.sin(angle) * radius - this.height / 2;

                // Charge attack (telegraphed)
                if (this.attackCooldown <= 0) {
                    this.attackPattern++;
                    if (this.attackPattern % 3 === 0) {
                        // Windup
                        this.stateTimer = 1000;
                        setTimeout(() => {
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            const chargeAngle = Math.atan2(dy, dx);
                            this.knockbackX = Math.cos(chargeAngle) * 20;
                            this.knockbackY = Math.sin(chargeAngle) * 20;
                        }, 1000);
                    }
                    this.attackCooldown = 3000;
                }
            }

            updateFoxyBehavior(dt, player) {
                // Fast dash attacks
                if (this.attackCooldown <= 0) {
                    if (this.attackPattern % 2 === 0) {
                        // Run to corner
                        const corners = [
                            {x: 50, y: 50},
                            {x: GAME_WIDTH - 50, y: 50},
                            {x: 50, y: GAME_HEIGHT - 50},
                            {x: GAME_WIDTH - 50, y: GAME_HEIGHT - 50}
                        ];
                        const corner = corners[Math.floor(Math.random() * corners.length)];
                        const angle = Math.atan2(corner.y - this.y, corner.x - this.x);
                        this.x += Math.cos(angle) * 10;
                        this.y += Math.sin(angle) * 10;
                    } else {
                        // Charge at player
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const angle = Math.atan2(dy, dx);
                        this.knockbackX = Math.cos(angle) * 25;
                        this.knockbackY = Math.sin(angle) * 25;
                    }
                    this.attackPattern++;
                    this.attackCooldown = 2000;
                }
            }

            updateTwinsBehavior(dt, player) {
                // This is handled with two separate bosses in the game state
            }

            updateBonnieBehavior(dt, player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Guitar soundwave attacks
                if (this.attackCooldown <= 0) {
                    if (this.attackPattern % 3 === 0) {
                        // Shockwave
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 * i) / 8;
                            this.projectiles.push({
                                x: this.x + this.width / 2,
                                y: this.y + this.height / 2,
                                vx: Math.cos(angle) * 2,
                                vy: Math.sin(angle) * 2,
                                life: 3000,
                                checkCollision(other) {
                                    const dist = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                                    return dist < 16;
                                }
                            });
                        }
                    } else if (this.attackPattern % 3 === 1) {
                        // Jump ground pound
                        this.y -= 30;
                        setTimeout(() => {
                            this.y += 30;
                            if (dist < 80) {
                                player.takeDamage(2);
                            }
                            ParticleSystem.createExplosion(this.x, this.y + this.height, '#8B4513');
                        }, 500);
                    }
                    this.attackPattern++;
                    this.attackCooldown = 2500;
                }
            }

            updateGoldenFreddyBehavior(dt, player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (this.phase === 1) {
                    // Slow powerful attacks
                    if (this.attackCooldown <= 0) {
                        // Slam fists
                        if (dist < 100) {
                            player.takeDamage(2);
                            ParticleSystem.createExplosion(player.x, player.y, '#FFD700');
                        }
                        this.attackCooldown = 3000;
                    }
                } else if (this.phase === 2) {
                    // Teleport and laser eyes
                    if (this.attackCooldown <= 0) {
                        if (this.attackPattern % 2 === 0) {
                            // Teleport
                            ParticleSystem.createExplosion(this.x, this.y, '#FFD700');
                            this.x = Math.random() * (GAME_WIDTH - this.width);
                            this.y = Math.random() * (GAME_HEIGHT - this.height);
                            ParticleSystem.createExplosion(this.x, this.y, '#FFD700');
                        } else {
                            // Laser eyes
                            const angle = Math.atan2(dy, dx);
                            for (let i = 0; i < 3; i++) {
                                this.projectiles.push({
                                    x: this.x + this.width / 2,
                                    y: this.y + this.height / 2,
                                    vx: Math.cos(angle + (i - 1) * 0.2) * 4,
                                    vy: Math.sin(angle + (i - 1) * 0.2) * 4,
                                    life: 2000,
                                    checkCollision(other) {
                                        const dist = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                                        return dist < 20;
                                    }
                                });
                            }
                        }
                        this.attackPattern++;
                        this.attackCooldown = 2000;
                    }
                } else if (this.phase === 3) {
                    // Berserk mode - constant aggression
                    const angle = Math.atan2(dy, dx);
                    this.x += Math.cos(angle) * this.speed * 2 * (dt / 16);
                    this.y += Math.sin(angle) * this.speed * 2 * (dt / 16);
                    
                    if (this.attackCooldown <= 0) {
                        if (dist < 50) {
                            player.takeDamage(1);
                        }
                        this.attackCooldown = 800;
                    }
                }
            }

            spawnMinions(count) {
                for (let i = 0; i < count; i++) {
                    const minion = new Enemy(
                        this.x + (Math.random() - 0.5) * 100,
                        this.y + (Math.random() - 0.5) * 100,
                        2,
                        1.5,
                        'basic'
                    );
                    this.minions.push(minion);
                }
            }

            draw(ctx) {
                // Boss shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + 4, this.y + this.height, this.width - 4, 8);

                // Boss body (larger, more detailed)
                ctx.fillStyle = this.getBossColor();
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Boss eyes (glowing)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(this.x + 8, this.y + 8, 6, 6);
                ctx.fillRect(this.x + this.width - 14, this.y + 8, 6, 6);

                // Boss health bar (larger)
                const barWidth = 200;
                const barX = GAME_WIDTH / 2 - barWidth / 2;
                ctx.fillStyle = '#000';
                ctx.fillRect(barX - 2, 10 - 2, barWidth + 4, 24);
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(barX, 10, barWidth, 20);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(barX, 10, barWidth * (this.health / this.maxHealth), 20);

                // Boss name
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 16px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, GAME_WIDTH / 2, 50);
                ctx.textAlign = 'left';

                // Phase indicator
                if (this.bossType === 'golden-freddy') {
                    ctx.fillText(`Phase ${this.phase}`, GAME_WIDTH / 2 - 30, 70);
                }

                // Draw minions
                this.minions.forEach(m => m.draw(ctx));

                // Draw projectiles (enhanced for boss)
                ctx.fillStyle = '#FFD700';
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 10;
                this.projectiles.forEach(p => {
                    ctx.fillRect(p.x - 4, p.y - 4, 8, 8);
                });
                ctx.shadowBlur = 0;
            }

            getBossColor() {
                switch(this.bossType) {
                    case 'chica': return '#FFFF00';
                    case 'foxy': return '#8B0000';
                    case 'twins': return '#FF00FF';
                    case 'bonnie': return '#4169E1';
                    case 'golden-freddy': return '#FFD700';
                    default: return '#555';
                }
            }
        }

        // ===================================
        // UI SYSTEM
        // ===================================

        const UI = {
            draw(ctx, player, level) {
                // Hearts
                for (let i = 0; i < player.maxHealth; i++) {
                    const sprite = i < player.health ? Sprites.heart : Sprites.heartEmpty;
                    ctx.drawImage(sprite, 10 + i * 18, 10);
                }

                // Keys
                ctx.fillStyle = '#FFF';
                ctx.font = '16px "Courier New"';
                ctx.fillText(`Keys: ${player.keys}`, 10, 50);

                // Level
                ctx.fillText(`Level ${level}`, GAME_WIDTH - 100, 30);

                // Cooldown indicators
                if (player.dodgeCooldown > 0) {
                    const cooldownPercent = player.dodgeCooldown / 1000;
                    ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
                    ctx.fillRect(10, GAME_HEIGHT - 30, 100 * (1 - cooldownPercent), 20);
                    ctx.strokeStyle = '#FFF';
                    ctx.strokeRect(10, GAME_HEIGHT - 30, 100, 20);
                }
            },

            drawDamageFlash(ctx, alpha) {
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            },

            drawHealFlash(ctx, alpha) {
                ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }
        };

        // ===================================
        // MAIN MENU STATE
        // ===================================

        GameState.states['MENU'] = {
            selectedOption: 0,
            options: ['New Game', 'Continue', 'Controls'],
            flickerTimer: 0,
            glowPhase: 0,
            showControls: false,
            clickListener: null,
            keyListener: null,

            enter() {
                Audio.playMusic('menu');
                // Gray out Continue if no save
                if (!SaveSystem.hasSave()) {
                    this.selectedOption = 0;
                }
                
                // Add click listener for menu options
                this.clickListener = (e) => this.handleClick(e);
                canvas.addEventListener('click', this.clickListener);
                
                // EMERGENCY FALLBACK: Direct keydown listener on document
                this.keyListener = (e) => {
                    console.log('EMERGENCY KEY LISTENER:', e.key);
                    if (e.key === ' ' || e.key === 'Enter' || e.key === 'e') {
                        e.preventDefault();
                        console.log('STARTING GAME FROM EMERGENCY LISTENER!');
                        this.selectOption();
                    }
                    if (e.key === 'ArrowDown' || e.key === 's') {
                        e.preventDefault();
                        if (this.selectedOption < this.options.length - 1) {
                            this.selectedOption++;
                            if (this.selectedOption === 1 && !SaveSystem.hasSave()) {
                                this.selectedOption = 2;
                            }
                            Audio.playSound('pickup');
                        }
                    }
                    if (e.key === 'ArrowUp' || e.key === 'w') {
                        e.preventDefault();
                        if (this.selectedOption > 0) {
                            this.selectedOption--;
                            if (this.selectedOption === 1 && !SaveSystem.hasSave()) {
                                this.selectedOption = 0;
                            }
                            Audio.playSound('pickup');
                        }
                    }
                };
                document.addEventListener('keydown', this.keyListener);
            },

            exit() {
                // Remove listeners when leaving menu
                if (this.clickListener) {
                    canvas.removeEventListener('click', this.clickListener);
                    this.clickListener = null;
                }
                if (this.keyListener) {
                    document.removeEventListener('keydown', this.keyListener);
                    this.keyListener = null;
                }
            },

            handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = GAME_WIDTH / rect.width;
                const scaleY = GAME_HEIGHT / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                if (this.showControls) {
                    this.showControls = false;
                    Audio.playSound('pickup');
                    return;
                }

                // Check if clicking on an option
                const optionY = 340;
                const optionHeight = 40;
                
                for (let i = 0; i < this.options.length; i++) {
                    // Skip Continue if no save
                    if (i === 1 && !SaveSystem.hasSave()) continue;
                    
                    const y = optionY + i * optionHeight;
                    if (mouseY >= y && mouseY < y + 30) {
                        this.selectedOption = i;
                        this.selectOption();
                        return;
                    }
                }
            },

            selectOption() {
                console.log('selectOption called! Option:', this.selectedOption);
                Audio.playSound('sword');
                switch(this.selectedOption) {
                    case 0: // New Game
                        console.log('Starting new game...');
                        SaveSystem.deleteSave();
                        GameState.setState('INTRO_CUTSCENE');
                        break;
                    case 1: // Continue
                        console.log('Loading save...');
                        const save = SaveSystem.load();
                        if (save) {
                            // Load appropriate level
                            const levelName = `LEVEL_${save.level}`;
                            if (GameState.states[levelName]) {
                                GameState.setState(levelName);
                                // Restore player stats
                                setTimeout(() => {
                                    const currentState = GameState.states[levelName];
                                    if (currentState.player) {
                                        currentState.player.health = save.health;
                                        currentState.player.maxHealth = save.maxHealth;
                                        currentState.player.keys = save.keys;
                                        currentState.player.hasBoots = save.hasBoots;
                                        currentState.player.hasShield = save.hasShield;
                                        currentState.player.hasFlashlight = save.hasFlashlight;
                                        currentState.player.arrows = save.arrows;
                                    }
                                }, 100);
                            }
                        }
                        break;
                    case 2: // Controls
                        console.log('Showing controls...');
                        this.showControls = true;
                        Audio.playSound('pickup');
                        break;
                }
            },

            update(dt) {
                this.flickerTimer += dt;
                this.glowPhase += dt / 1000;

                if (this.showControls) {
                    // ANY key closes controls - direct key check
                    if (Input.keys[' '] || Input.keys['enter'] || Input.keys['escape'] || Input.keys['e']) {
                        this.showControls = false;
                        Audio.playSound('pickup');
                        // Clear all keys
                        Object.keys(Input.keys).forEach(k => Input.keys[k] = false);
                        Object.keys(Input.prevKeys).forEach(k => Input.prevKeys[k] = false);
                    }
                    return;
                }

                // DIRECT key detection - bypass justPressed for immediate response
                const spacePressed = Input.keys[' '] && !Input.prevKeys[' '];
                const enterPressed = Input.keys['enter'] && !Input.prevKeys['enter'];
                const ePressed = Input.keys['e'] && !Input.prevKeys['e'];
                
                // Menu navigation with arrow keys
                if (Input.keys['arrowdown'] && !Input.prevKeys['arrowdown'] && this.selectedOption < this.options.length - 1) {
                    this.selectedOption++;
                    if (this.selectedOption === 1 && !SaveSystem.hasSave()) {
                        this.selectedOption = 2;
                    }
                    Audio.playSound('pickup');
                }
                if (Input.keys['arrowup'] && !Input.prevKeys['arrowup'] && this.selectedOption > 0) {
                    this.selectedOption--;
                    if (this.selectedOption === 1 && !SaveSystem.hasSave()) {
                        this.selectedOption = 0;
                    }
                    Audio.playSound('pickup');
                }
                if (Input.keys['s'] && !Input.prevKeys['s'] && this.selectedOption < this.options.length - 1) {
                    this.selectedOption++;
                    if (this.selectedOption === 1 && !SaveSystem.hasSave()) {
                        this.selectedOption = 2;
                    }
                    Audio.playSound('pickup');
                }
                if (Input.keys['w'] && !Input.prevKeys['w'] && this.selectedOption > 0) {
                    this.selectedOption--;
                    if (this.selectedOption === 1 && !SaveSystem.hasSave()) {
                        this.selectedOption = 0;
                    }
                    Audio.playSound('pickup');
                }

                // Select option with SPACE, ENTER, or E
                if (spacePressed || enterPressed || ePressed) {
                    console.log('ACTIVATING MENU OPTION:', this.selectedOption);
                    this.selectOption();
                }
            },

            draw(ctx) {
                if (this.showControls) {
                    // Controls screen
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px "Courier New"';
                    ctx.textAlign = 'center';
                    ctx.fillText('CONTROLS', GAME_WIDTH / 2, 80);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '14px "Courier New"';
                    ctx.fillText('(Click anywhere to close)', GAME_WIDTH / 2, 110);
                    
                    ctx.font = '18px "Courier New"';
                    ctx.fillStyle = '#FFF';
                    ctx.fillText('DESKTOP:', GAME_WIDTH / 2, 140);
                    ctx.font = '16px "Courier New"';
                    ctx.fillText('WASD / Arrow Keys - Move', GAME_WIDTH / 2, 180);
                    ctx.fillText('SPACE - Attack', GAME_WIDTH / 2, 210);
                    ctx.fillText('SHIFT - Dodge Roll', GAME_WIDTH / 2, 240);
                    ctx.fillText('E - Interact / Shield', GAME_WIDTH / 2, 270);
                    ctx.fillText('ESC - Pause', GAME_WIDTH / 2, 300);
                    
                    ctx.font = '18px "Courier New"';
                    ctx.fillText('MOBILE:', GAME_WIDTH / 2, 360);
                    ctx.font = '16px "Courier New"';
                    ctx.fillText('D-Pad - Move', GAME_WIDTH / 2, 400);
                    ctx.fillText('âš”ï¸ Button - Attack', GAME_WIDTH / 2, 430);
                    ctx.fillText('ROLL Button - Dodge', GAME_WIDTH / 2, 460);
                    ctx.fillText('E Button - Interact / Shield', GAME_WIDTH / 2, 490);
                    
                    ctx.fillStyle = '#888';
                    ctx.font = '14px "Courier New"';
                    ctx.fillText('Press SPACE or TAP to return', GAME_WIDTH / 2, 560);
                    ctx.textAlign = 'left';
                    return;
                }

                // Background (pizzeria exterior)
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Animated stars
                for (let i = 0; i < 50; i++) {
                    const x = (i * 137.5) % GAME_WIDTH;
                    const y = (i * 217.3) % GAME_HEIGHT;
                    const flicker = Math.sin(this.flickerTimer / 100 + i) > 0.5;
                    if (flicker) {
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(x, y, 2, 2);
                    }
                }

                // Pizzeria building silhouette
                ctx.fillStyle = '#0f0f1e';
                ctx.fillRect(100, 300, 600, 250);
                ctx.fillStyle = '#1a1a3e';
                ctx.fillRect(350, 200, 100, 100); // Roof
                
                // Flickering windows
                const windowFlicker = Math.sin(this.flickerTimer / 200) > 0;
                ctx.fillStyle = windowFlicker ? '#FFD700' : '#AA8800';
                ctx.fillRect(150, 350, 60, 80);
                ctx.fillRect(300, 350, 60, 80);
                ctx.fillRect(450, 350, 60, 80);
                ctx.fillRect(590, 350, 60, 80);

                // Title with glow effect
                const glow = Math.sin(this.glowPhase) * 0.3 + 0.7;
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 20 * glow;
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 36px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText("JOSE'S QUEST", GAME_WIDTH / 2, 100);
                ctx.font = 'bold 24px "Courier New"';
                ctx.fillText("SAVING GABBY", GAME_WIDTH / 2, 140);
                ctx.shadowBlur = 0;

                // Menu options
                ctx.font = '20px "Courier New"';
                this.options.forEach((option, index) => {
                    const y = 250 + index * 40;
                    const isDisabled = (index === 1 && !SaveSystem.hasSave());
                    
                    if (index === this.selectedOption) {
                        ctx.fillStyle = '#FFD700';
                        ctx.fillText('â–º ' + option, GAME_WIDTH / 2, y);
                    } else {
                        ctx.fillStyle = isDisabled ? '#444' : '#AAA';
                        ctx.fillText(option, GAME_WIDTH / 2, y);
                    }
                });

                // Instruction text
                ctx.fillStyle = '#888';
                ctx.font = '12px "Courier New"';
                ctx.fillText('CLICK option or use â†‘â†“ + SPACE/ENTER', GAME_WIDTH / 2, GAME_HEIGHT - 40);
                
                // Debug: show last key pressed
                if (Input.debugText) {
                    ctx.fillStyle = '#0F0';
                    ctx.font = '10px "Courier New"';
                    ctx.fillText(Input.debugText, GAME_WIDTH / 2, GAME_HEIGHT - 20);
                }

                // Press START hint
                if (Math.floor(this.flickerTimer / 500) % 2 === 0) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = '16px "Courier New"';
                    ctx.fillText('Press SPACE/ENTER or CLICK', GAME_WIDTH / 2, 500);
                }

                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // INTRO CUTSCENE STATE  
        // ===================================

        GameState.states['INTRO_CUTSCENE'] = {
            scene: 0,
            timer: 0,
            charIndex: 0,
            textTimer: 0,
            scenes: [
                { 
                    title: "THE DATE",
                    text: "Jose: 'This place is amazing, right Gabby?'",
                    duration: 3500,
                    color: '#FFD700'
                },
                {
                    title: "THE DATE", 
                    text: "Gabby: 'Anything with you is perfect, Jose. â¤ï¸'",
                    duration: 3500,
                    color: '#FF69B4'
                },
                { 
                    title: "THE ATTACK",
                    text: "***THE LIGHTS FLICKER***",
                    duration: 2000,
                    color: '#FF0000'
                },
                { 
                    title: "THE ATTACK",
                    text: "The animatronics' eyes glow red...",
                    duration: 2500,
                    color: '#8B0000'
                },
                { 
                    title: "THE ATTACK",
                    text: "Gabby: 'JOSE! HELP ME!'",
                    duration: 2500,
                    color: '#FF1493'
                },
                { 
                    title: "THE CAPTURE",
                    text: "GOLDEN FREDDY appears from the shadows!",
                    duration: 2500,
                    color: '#DAA520'
                },
                { 
                    title: "THE CAPTURE",
                    text: "He drags Gabby into the darkness...",
                    duration: 3000,
                    color: '#FFD700'
                },
                { 
                    title: "JOSE'S DETERMINATION",
                    text: "Jose: 'GABBY!! I'M COMING FOR YOU!'",
                    duration: 3000,
                    color: '#00FF00'
                },
                { 
                    title: "JOSE'S DETERMINATION",
                    text: "Jose: 'Nothing will keep us apart!'",
                    duration: 3000,
                    color: '#00FF00'
                },
                { 
                    title: "THE QUEST BEGINS",
                    text: "A LOVE WORTH FIGHTING FOR...",
                    duration: 3500,
                    color: '#FF1493'
                }
            ],

            enter() {
                this.scene = 0;
                this.timer = 0;
                this.charIndex = 0;
                this.textTimer = 0;
            },

            update(dt) {
                this.timer += dt;
                this.textTimer += dt;
                
                // Character typing effect - one character every 50ms
                const currentScene = this.scenes[this.scene];
                if (this.charIndex < currentScene.text.length && this.textTimer >= 50) {
                    this.charIndex++;
                    this.textTimer = 0;
                    // Typing sound effect
                    if (this.charIndex % 2 === 0) {
                        Audio.playSound('pickup', 0.3);
                    }
                }

                if (this.timer >= currentScene.duration && this.charIndex >= currentScene.text.length) {
                    this.scene++;
                    this.timer = 0;
                    this.charIndex = 0;
                    this.textTimer = 0;

                    if (this.scene >= this.scenes.length) {
                        GameState.setState('LEVEL_1');
                    }
                }
                
                // Skip cutscene
                if (Input.keys['enter'] || Input.keys[' ']) {
                    GameState.setState('LEVEL_1');
                }
            },            draw(ctx) {
                // Black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                const currentScene = this.scenes[this.scene];
                
                // Animated stars background
                for (let i = 0; i < 80; i++) {
                    const x = (i * 137.5) % GAME_WIDTH;
                    const y = (i * 217.3) % GAME_HEIGHT;
                    const flicker = Math.sin(this.timer / 100 + i) > 0.3;
                    if (flicker) {
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(x, y, 2, 2);
                    }
                }

                // Scene title
                ctx.fillStyle = currentScene.color;
                ctx.font = 'bold 28px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText(currentScene.title, GAME_WIDTH / 2, 150);

                // Animated visual depending on scene
                if (this.scene < 2) {
                    // Draw Jose and Gabby at table
                    ctx.drawImage(Sprites.jose.down[0], 320, 240, 48, 48);
                    ctx.drawImage(Sprites.gabby, 420, 240, 48, 48);
                    // Table with pizza
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(350, 280, 100, 60);
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(400, 300, 20, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.scene >= 7) {
                    // Draw beating heart
                    const heartBeat = Math.sin(this.timer / 200) * 8 + 40;
                    ctx.fillStyle = '#FF1493';
                    ctx.font = `${heartBeat}px Arial`;
                    ctx.fillText('â¤ï¸', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);
                    
                    // Sparkles around heart
                    for (let i = 0; i < 20; i++) {
                        const angle = (this.timer / 20 + i * 18) * Math.PI / 180;
                        const radius = 80 + Math.sin(this.timer / 100 + i) * 20;
                        const sx = GAME_WIDTH / 2 + Math.cos(angle) * radius;
                        const sy = GAME_HEIGHT / 2 - 40 + Math.sin(angle) * radius;
                        ctx.fillStyle = i % 2 === 0 ? '#FFD700' : '#FF69B4';
                        ctx.fillRect(sx, sy, 3, 3);
                    }
                } else {
                    // Draw menacing animatronic silhouette
                    ctx.fillStyle = '#222';
                    ctx.fillRect(GAME_WIDTH / 2 - 40, GAME_HEIGHT / 2 - 100, 80, 100);
                    // Glowing red eyes with intensity
                    const eyeGlow = Math.sin(this.timer / 100) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(255, 0, 0, ${eyeGlow})`;
                    ctx.fillRect(GAME_WIDTH / 2 - 25, GAME_HEIGHT / 2 - 70, 15, 15);
                    ctx.fillRect(GAME_WIDTH / 2 + 10, GAME_HEIGHT / 2 - 70, 15, 15);
                    // Eye glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FF0000';
                    ctx.fillRect(GAME_WIDTH / 2 - 25, GAME_HEIGHT / 2 - 70, 15, 15);
                    ctx.fillRect(GAME_WIDTH / 2 + 10, GAME_HEIGHT / 2 - 70, 15, 15);
                    ctx.shadowBlur = 0;
                }

                // Text box at bottom with typing effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(50, GAME_HEIGHT - 150, GAME_WIDTH - 100, 100);
                ctx.strokeStyle = currentScene.color;
                ctx.lineWidth = 4;
                ctx.strokeRect(50, GAME_HEIGHT - 150, GAME_WIDTH - 100, 100);

                // Display text with typing animation
                ctx.fillStyle = '#FFF';
                ctx.font = '22px "Courier New"';
                ctx.textAlign = 'center';
                const displayText = currentScene.text.substring(0, this.charIndex);
                ctx.fillText(displayText, GAME_WIDTH / 2, GAME_HEIGHT - 90);

                // Cursor blink if text not complete
                if (this.charIndex < currentScene.text.length && Math.floor(this.timer / 300) % 2 === 0) {
                    ctx.fillStyle = currentScene.color;
                    ctx.fillText('â–®', GAME_WIDTH / 2 + ctx.measureText(displayText).width / 2 + 5, GAME_HEIGHT - 90);
                }

                // Prompt
                ctx.fillStyle = '#888';
                ctx.font = '14px "Courier New"';
                ctx.fillText('Press SPACE/ENTER to skip', GAME_WIDTH / 2, GAME_HEIGHT - 30);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // LEVEL 1 STATE (DINING HALL)
        // ===================================

        GameState.states['LEVEL_1'] = {
            player: null,
            enemies: [],
            items: [],
            walls: [],
            floor: null,

            enter() {
                // Initialize player
                this.player = new Player(GAME_WIDTH / 2, GAME_HEIGHT / 2);

                // Create enemies
                for (let i = 0; i < 4; i++) {
                    const enemy = new Enemy(
                        100 + i * 150,
                        100 + (i % 2) * 200,
                        3, // health
                        1  // speed
                    );
                    enemy.patrolPoints = [
                        { x: enemy.x, y: enemy.y },
                        { x: enemy.x + 100, y: enemy.y },
                        { x: enemy.x + 100, y: enemy.y + 100 },
                        { x: enemy.x, y: enemy.y + 100 }
                    ];
                    this.enemies.push(enemy);
                }

                // Create items (keys)
                this.items = [
                    { x: 100, y: 100, type: 'key' },
                    { x: 600, y: 400, type: 'key' },
                    { x: 400, y: 200, type: 'key' }
                ];

                Audio.playMusic('level1');
            },

            update(dt) {
                // Update player
                this.player.update(dt);

                // Update enemies
                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(dt, this.player);

                    // Check if player attacked enemy
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && enemy.checkCollision(attackBox)) {
                        return !enemy.takeDamage(1, this.player.x, this.player.y);
                    }

                    return true;
                });

                // Check item pickups
                this.items = this.items.filter(item => {
                    const dx = item.x - this.player.x;
                    const dy = item.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 20) {
                        if (item.type === 'key') {
                            this.player.keys++;
                            Audio.playSound('pickup');
                            ParticleSystem.createExplosion(item.x, item.y, '#FFD700');
                        }
                        return false;
                    }
                    return true;
                });

                // Update particles
                ParticleSystem.update(dt);

                // Check win condition (all keys collected)
                if (this.player.keys >= 3 && this.enemies.length === 0) {
                    // Progress to boss or next level
                    // GameState.setState('BOSS_1');
                }
            },

            draw(ctx) {
                // Draw floor
                ctx.fillStyle = '#2a2a3e';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Draw checkered floor pattern
                for (let x = 0; x < GAME_WIDTH; x += TILE_SIZE * 2) {
                    for (let y = 0; y < GAME_HEIGHT; y += TILE_SIZE * 2) {
                        if ((x + y) % (TILE_SIZE * 4) === 0) {
                            ctx.fillStyle = '#3a3a4e';
                            ctx.fillRect(x, y, TILE_SIZE * 2, TILE_SIZE * 2);
                        }
                    }
                }

                // Draw items
                this.items.forEach(item => {
                    if (item.type === 'key') {
                        ctx.drawImage(Sprites.key, item.x, item.y);
                    }
                });

                // Draw enemies
                this.enemies.forEach(enemy => enemy.draw(ctx));

                // Draw player
                this.player.draw(ctx);

                // Draw particles
                ParticleSystem.draw(ctx);

                // Draw UI
                UI.draw(ctx, this.player, 1);

                // Story text
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, GAME_HEIGHT - 80, GAME_WIDTH, 80);
                ctx.fillStyle = '#FFD700';
                ctx.font = '16px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Find 3 keys to unlock the kitchen door!', GAME_WIDTH / 2, GAME_HEIGHT - 50);
                ctx.fillText(`Keys: ${this.player.keys}/3`, GAME_WIDTH / 2, GAME_HEIGHT - 25);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // BOSS 1: CHICA'S SHADOW
        // ===================================

        GameState.states['BOSS_1'] = {
            player: null,
            boss: null,
            storyShown: false,

            enter() {
                this.player = GameState.states['LEVEL_1'].player || new Player(GAME_WIDTH / 2, GAME_HEIGHT - 100);
                this.boss = new Boss(GAME_WIDTH / 2 - 16, 100, 30, "CHICA'S SHADOW", 'chica');
            },

            update(dt) {
                if (!this.storyShown) {
                    // Show story moment
                    this.storyShown = true;
                }

                this.player.update(dt);
                this.boss.update(dt, this.player);

                // Check player attack
                const attackBox = this.player.getAttackBox();
                if (attackBox && this.boss.checkCollision(attackBox)) {
                    if (this.boss.takeDamage(1, this.player.x, this.player.y)) {
                        // Boss defeated - drop items and progress
                        this.player.maxHealth++;
                        this.player.health = this.player.maxHealth;
                        ParticleSystem.createHeal(this.player.x, this.player.y);
                        setTimeout(() => {
                            SaveSystem.save(this.player, 2);
                            GameState.setState('LEVEL_2');
                        }, 2000);
                    }
                }

                // Check boss minions
                this.boss.minions.forEach(minion => {
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && minion.checkCollision(attackBox)) {
                        minion.takeDamage(1, this.player.x, this.player.y);
                    }
                });

                ParticleSystem.update(dt);
            },

            draw(ctx) {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                this.boss.draw(ctx);
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 1);

                // Story text at bottom
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, GAME_HEIGHT - 60, GAME_WIDTH, 60);
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('"Stay strong, Gabby..."', GAME_WIDTH / 2, GAME_HEIGHT - 30);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // LEVEL 2: KITCHEN ZONE
        // ===================================

        GameState.states['LEVEL_2'] = {
            player: null,
            enemies: [],
            items: [],
            hazards: [],
            switches: [],

            enter() {
                this.player = GameState.states['BOSS_1']?.player || new Player(50, GAME_HEIGHT / 2);
                this.player.keys = 0;

                // Chef enemies
                for (let i = 0; i < 3; i++) {
                    const enemy = new Enemy(
                        200 + i * 200,
                        150 + (i % 2) * 200,
                        5,
                        1.5,
                        'chef'
                    );
                    this.enemies.push(enemy);
                }

                // Fire hazards
                this.hazards = [
                    { x: 200, y: 300, width: 50, height: 50, type: 'fire', timer: 0 },
                    { x: 500, y: 200, width: 50, height: 50, type: 'fire', timer: 1000 },
                    { x: 300, y: 450, width: 50, height: 50, type: 'fire', timer: 500 }
                ];

                // Switches for puzzle
                this.switches = [
                    { x: 100, y: 100, active: false },
                    { x: 700, y: 100, active: false },
                    { x: 400, y: 500, active: false }
                ];

                // Bow and arrows
                this.items = [
                    { x: 650, y: 300, type: 'bow' },
                    { x: 150, y: 400, type: 'arrows', amount: 10 }
                ];
            },

            update(dt) {
                this.player.update(dt);

                // Update enemies
                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(dt, this.player);
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && enemy.checkCollision(attackBox)) {
                        return !enemy.takeDamage(1, this.player.x, this.player.y);
                    }
                    return true;
                });

                // Update hazards
                this.hazards.forEach(h => {
                    h.timer += dt;
                    if (h.timer % 2000 < 1000) { // Active half the time
                        if (this.player.x < h.x + h.width && this.player.x + this.player.width > h.x &&
                            this.player.y < h.y + h.height && this.player.y + this.player.height > h.y) {
                            if (!this.player.invincible) {
                                this.player.takeDamage(1);
                            }
                        }
                    }
                });

                // Check switches
                this.switches.forEach(s => {
                    const dist = Math.sqrt((s.x - this.player.x) ** 2 + (s.y - this.player.y) ** 2);
                    if (dist < 30 && Input.isDown('interact')) {
                        s.active = true;
                        Audio.playSound('pickup');
                    }
                });

                // Check items
                this.items = this.items.filter(item => {
                    const dist = Math.sqrt((item.x - this.player.x) ** 2 + (item.y - this.player.y) ** 2);
                    if (dist < 25) {
                        if (item.type === 'bow') {
                            this.player.hasBoots = true; // Using hasBoots as flag for bow
                            Audio.playSound('pickup');
                            return false;
                        } else if (item.type === 'arrows') {
                            this.player.arrows += item.amount;
                            Audio.playSound('pickup');
                            return false;
                        }
                    }
                    return true;
                });

                ParticleSystem.update(dt);

                // Win condition
                if (this.switches.every(s => s.active) && this.enemies.length === 0) {
                    GameState.setState('BOSS_2');
                }
            },

            draw(ctx) {
                // Kitchen floor
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Tiles
                for (let x = 0; x < GAME_WIDTH; x += TILE_SIZE) {
                    for (let y = 0; y < GAME_HEIGHT; y += TILE_SIZE) {
                        if ((x + y) % (TILE_SIZE * 2) === 0) {
                            ctx.fillStyle = '#4a4a4a';
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }

                // Draw hazards
                this.hazards.forEach(h => {
                    const active = h.timer % 2000 < 1000;
                    ctx.fillStyle = active ? '#FF4500' : '#8B0000';
                    ctx.fillRect(h.x, h.y, h.width, h.height);
                    if (active) {
                        ParticleSystem.createExplosion(h.x + h.width/2, h.y, '#FFA500');
                    }
                });

                // Draw switches
                this.switches.forEach(s => {
                    ctx.fillStyle = s.active ? '#00FF00' : '#888';
                    ctx.fillRect(s.x, s.y, 20, 20);
                });

                // Draw items
                this.items.forEach(item => {
                    ctx.fillStyle = '#4169E1';
                    ctx.fillRect(item.x, item.y, 16, 16);
                });

                this.enemies.forEach(e => e.draw(ctx));
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 2);

                // Story
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, GAME_HEIGHT - 70, GAME_WIDTH, 70);
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Activate all switches to unlock the door!', GAME_WIDTH / 2, GAME_HEIGHT - 40);
                ctx.fillText(`Switches: ${this.switches.filter(s => s.active).length}/3`, GAME_WIDTH / 2, GAME_HEIGHT - 20);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // BOSS 2: FOXY THE SWIFT
        // ===================================

        GameState.states['BOSS_2'] = {
            player: null,
            boss: null,

            enter() {
                this.player = GameState.states['LEVEL_2'].player || new Player(GAME_WIDTH / 2, GAME_HEIGHT - 100);
                this.boss = new Boss(GAME_WIDTH / 2 - 16, 100, 40, "FOXY THE SWIFT", 'foxy');
            },

            update(dt) {
                this.player.update(dt);
                this.boss.update(dt, this.player);

                const attackBox = this.player.getAttackBox();
                if (attackBox && this.boss.checkCollision(attackBox)) {
                    if (this.boss.takeDamage(1, this.player.x, this.player.y)) {
                        setTimeout(() => {
                            SaveSystem.save(this.player, 3);
                            GameState.setState('LEVEL_3');
                        }, 2000);
                    }
                }

                ParticleSystem.update(dt);
            },

            draw(ctx) {
                ctx.fillStyle = '#2a1a1a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                this.boss.draw(ctx);
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 2);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, GAME_HEIGHT - 50, GAME_WIDTH, 50);
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Security Log: Subject secured in main stage area', GAME_WIDTH / 2, GAME_HEIGHT - 25);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // LEVEL 3: ARCADE ROOM
        // ===================================

        GameState.states['LEVEL_3'] = {
            player: null,
            enemies: [],
            arcadeMachines: [],
            items: [],
            lightTimer: 0,
            darkMode: false,

            enter() {
                this.player = GameState.states['BOSS_2']?.player || new Player(50, GAME_HEIGHT / 2);

                // Arcade bots
                for (let i = 0; i < 4; i++) {
                    this.enemies.push(new Enemy(
                        150 + i * 150,
                        200 + (i % 2) * 150,
                        4,
                        1.8,
                        'arcade'
                    ));
                }

                // Arcade machines (puzzle)
                this.arcadeMachines = [
                    { x: 100, y: 100, active: false, sequence: 1 },
                    { x: 300, y: 100, active: false, sequence: 2 },
                    { x: 500, y: 100, active: false, sequence: 3 },
                    { x: 700, y: 100, active: false, sequence: 4 }
                ];

                this.items = [
                    { x: 400, y: 300, type: 'shield' }
                ];
            },

            update(dt) {
                this.lightTimer += dt;
                this.darkMode = Math.floor(this.lightTimer / 3000) % 2 === 1;

                this.player.update(dt);

                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(dt, this.player);
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && enemy.checkCollision(attackBox)) {
                        return !enemy.takeDamage(1, this.player.x, this.player.y);
                    }
                    return true;
                });

                // Arcade machines
                this.arcadeMachines.forEach((m, idx) => {
                    const dist = Math.sqrt((m.x - this.player.x) ** 2 + (m.y - this.player.y) ** 2);
                    if (dist < 30 && Input.isDown('interact')) {
                        const lastActive = this.arcadeMachines.findIndex(machine => machine.active);
                        if (lastActive === -1 && idx === 0) {
                            m.active = true;
                            Audio.playSound('pickup');
                        } else if (lastActive === idx - 1) {
                            m.active = true;
                            Audio.playSound('pickup');
                        }
                    }
                });

                // Items
                this.items = this.items.filter(item => {
                    const dist = Math.sqrt((item.x - this.player.x) ** 2 + (item.y - this.player.y) ** 2);
                    if (dist < 25 && item.type === 'shield') {
                        this.player.hasShield = true;
                        Audio.playSound('pickup');
                        return false;
                    }
                    return true;
                });

                ParticleSystem.update(dt);

                if (this.arcadeMachines.every(m => m.active) && this.enemies.length === 0) {
                    GameState.setState('BOSS_3');
                }
            },

            draw(ctx) {
                // Neon background
                ctx.fillStyle = this.darkMode ? '#0a0a1a' : '#1a1a3a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Neon grid
                ctx.strokeStyle = this.darkMode ? '#220044' : '#4400AA';
                ctx.lineWidth = 2;
                for (let x = 0; x < GAME_WIDTH; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, GAME_HEIGHT);
                    ctx.stroke();
                }

                // Arcade machines
                this.arcadeMachines.forEach(m => {
                    ctx.fillStyle = m.active ? '#00FF00' : '#FF00FF';
                    ctx.fillRect(m.x, m.y, 40, 60);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(m.x + 5, m.y + 5, 30, 30);
                });

                this.items.forEach(item => {
                    ctx.fillStyle = '#4169E1';
                    ctx.fillRect(item.x, item.y, 16, 16);
                });

                this.enemies.forEach(e => e.draw(ctx));
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 3);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, GAME_HEIGHT - 70, GAME_WIDTH, 70);
                ctx.fillStyle = '#00FFFF';
                ctx.font = '14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Activate arcade machines in order!', GAME_WIDTH / 2, GAME_HEIGHT - 40);
                ctx.fillText('"Jose, I know you\'ll save me. I love you."', GAME_WIDTH / 2, GAME_HEIGHT - 20);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // BOSS 3: TWIN ANIMATRONICS
        // ===================================

        GameState.states['BOSS_3'] = {
            player: null,
            boss1: null,
            boss2: null,
            defeatTimer: 0,

            enter() {
                this.player = GameState.states['LEVEL_3']?.player || new Player(GAME_WIDTH / 2, GAME_HEIGHT - 100);
                this.boss1 = new Boss(200, 150, 25, "TWIN 1", 'twins');
                this.boss2 = new Boss(550, 150, 25, "TWIN 2", 'twins');
            },

            update(dt) {
                this.player.update(dt);
                this.boss1.update(dt, this.player);
                this.boss2.update(dt, this.player);

                const attackBox = this.player.getAttackBox();
                
                if (attackBox && this.boss1.checkCollision(attackBox)) {
                    if (this.boss1.takeDamage(1, this.player.x, this.player.y)) {
                        this.defeatTimer = Date.now();
                    }
                }
                
                if (attackBox && this.boss2.checkCollision(attackBox)) {
                    if (this.boss2.takeDamage(1, this.player.x, this.player.y)) {
                        this.defeatTimer = Date.now();
                    }
                }

                // Revive mechanic
                if (this.boss1.health <= 0 && this.boss2.health > 0) {
                    if (Date.now() - this.defeatTimer > 30000) {
                        this.boss1.health = this.boss1.maxHealth / 2;
                        ParticleSystem.createExplosion(this.boss1.x, this.boss1.y, '#FF00FF');
                    }
                }
                if (this.boss2.health <= 0 && this.boss1.health > 0) {
                    if (Date.now() - this.defeatTimer > 30000) {
                        this.boss2.health = this.boss2.maxHealth / 2;
                        ParticleSystem.createExplosion(this.boss2.x, this.boss2.y, '#FF00FF');
                    }
                }

                // Both defeated
                if (this.boss1.health <= 0 && this.boss2.health <= 0) {
                    setTimeout(() => {
                        SaveSystem.save(this.player, 4);
                        GameState.setState('LEVEL_4');
                    }, 2000);
                }

                ParticleSystem.update(dt);
            },

            draw(ctx) {
                ctx.fillStyle = '#1a0a2a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                this.boss1.draw(ctx);
                this.boss2.draw(ctx);
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 3);
            }
        };

        // ===================================
        // LEVEL 4: PARTS & SERVICE
        // ===================================

        GameState.states['LEVEL_4'] = {
            player: null,
            enemies: [],
            items: [],
            circuitParts: [],
            visibility: 100,

            enter() {
                this.player = GameState.states['BOSS_3']?.player || new Player(50, GAME_HEIGHT / 2);

                // Shadow enemies
                for (let i = 0; i < 5; i++) {
                    this.enemies.push(new Enemy(
                        100 + i * 130,
                        100 + (i % 2) * 300,
                        6,
                        1.2,
                        'shadow'
                    ));
                }

                // Circuit board parts
                this.circuitParts = [
                    { x: 150, y: 150, placed: false },
                    { x: 400, y: 200, placed: false },
                    { x: 600, y: 350, placed: false }
                ];

                this.items = [
                    { x: 350, y: 450, type: 'flashlight' }
                ];
            },

            update(dt) {
                this.player.update(dt);

                // Reduce visibility over time
                if (!this.player.hasFlashlight) {
                    this.visibility = Math.max(50, this.visibility - dt / 100);
                } else {
                    this.visibility = 150;
                }

                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(dt, this.player);
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && enemy.checkCollision(attackBox)) {
                        return !enemy.takeDamage(1, this.player.x, this.player.y);
                    }
                    return true;
                });

                // Circuit parts
                this.circuitParts.forEach(part => {
                    const dist = Math.sqrt((part.x - this.player.x) ** 2 + (part.y - this.player.y) ** 2);
                    if (dist < 30 && Input.isDown('interact')) {
                        part.placed = true;
                        Audio.playSound('pickup');
                    }
                });

                // Items
                this.items = this.items.filter(item => {
                    const dist = Math.sqrt((item.x - this.player.x) ** 2 + (item.y - this.player.y) ** 2);
                    if (dist < 25 && item.type === 'flashlight') {
                        this.player.hasFlashlight = true;
                        Audio.playSound('pickup');
                        return false;
                    }
                    return true;
                });

                ParticleSystem.update(dt);

                if (this.circuitParts.every(p => p.placed) && this.enemies.length === 0) {
                    GameState.setState('BOSS_4');
                }
            },

            draw(ctx) {
                // Dark room
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Light circle around player
                const gradient = ctx.createRadialGradient(
                    this.player.x + 8, this.player.y + 8, 0,
                    this.player.x + 8, this.player.y + 8, this.visibility
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                
                // Draw everything in darkness
                this.circuitParts.forEach(part => {
                    ctx.fillStyle = part.placed ? '#00FF00' : '#FFD700';
                    ctx.fillRect(part.x, part.y, 20, 20);
                });

                this.items.forEach(item => {
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(item.x, item.y, 16, 16);
                });

                this.enemies.forEach(e => e.draw(ctx));
                this.player.draw(ctx);

                // Apply darkness overlay
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 4);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, GAME_HEIGHT - 70, GAME_WIDTH, 70);
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Reassemble circuit board parts!', GAME_WIDTH / 2, GAME_HEIGHT - 40);
                ctx.fillText('Security footage shows Gabby on the stage...', GAME_WIDTH / 2, GAME_HEIGHT - 20);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // BOSS 4: BONNIE'S RAGE
        // ===================================

        GameState.states['BOSS_4'] = {
            player: null,
            boss: null,

            enter() {
                this.player = GameState.states['LEVEL_4']?.player || new Player(GAME_WIDTH / 2, GAME_HEIGHT - 100);
                this.boss = new Boss(GAME_WIDTH / 2 - 16, 100, 50, "BONNIE'S RAGE", 'bonnie');
            },

            update(dt) {
                this.player.update(dt);
                this.boss.update(dt, this.player);

                const attackBox = this.player.getAttackBox();
                if (attackBox && this.boss.checkCollision(attackBox)) {
                    if (this.boss.takeDamage(1, this.player.x, this.player.y)) {
                        setTimeout(() => {
                            SaveSystem.save(this.player, 5);
                            GameState.setState('LEVEL_5');
                        }, 2000);
                    }
                }

                this.boss.minions.forEach(minion => {
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && minion.checkCollision(attackBox)) {
                        minion.takeDamage(1, this.player.x, this.player.y);
                    }
                });

                ParticleSystem.update(dt);
            },

            draw(ctx) {
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                this.boss.draw(ctx);
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 4);
            }
        };

        // ===================================
        // LEVEL 5: THE STAGE (FINAL)
        // ===================================

        GameState.states['LEVEL_5'] = {
            player: null,
            enemies: [],
            hazards: [],
            gauntletPhase: 0,

            enter() {
                this.player = GameState.states['BOSS_4']?.player || new Player(GAME_WIDTH / 2, GAME_HEIGHT - 100);
                this.spawnGauntletWave();
            },

            spawnGauntletWave() {
                if (this.gauntletPhase < 3) {
                    // Spawn mix of all enemy types
                    const types = ['basic', 'chef', 'arcade', 'shadow'];
                    for (let i = 0; i < 3; i++) {
                        const type = types[this.gauntletPhase];
                        this.enemies.push(new Enemy(
                            100 + i * 250,
                            100,
                            3 + this.gauntletPhase,
                            1 + this.gauntletPhase * 0.3,
                            type
                        ));
                    }
                }
            },

            update(dt) {
                this.player.update(dt);

                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(dt, this.player);
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && enemy.checkCollision(attackBox)) {
                        return !enemy.takeDamage(1, this.player.x, this.player.y);
                    }
                    return true;
                });

                // Next wave
                if (this.enemies.length === 0 && this.gauntletPhase < 3) {
                    this.gauntletPhase++;
                    this.spawnGauntletWave();
                } else if (this.enemies.length === 0 && this.gauntletPhase >= 3) {
                    GameState.setState('FINAL_BOSS');
                }

                ParticleSystem.update(dt);
            },

            draw(ctx) {
                // Stage with spotlights
                ctx.fillStyle = '#1a0a0a';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Spotlights
                const spotlightX = GAME_WIDTH / 2 + Math.sin(Date.now() / 1000) * 200;
                const gradient = ctx.createRadialGradient(spotlightX, 0, 0, spotlightX, GAME_HEIGHT / 2, 300);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                this.enemies.forEach(e => e.draw(ctx));
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 5);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, GAME_HEIGHT - 50, GAME_WIDTH, 50);
                ctx.fillStyle = '#FFD700';
                ctx.font = '16px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('"Almost there, hold on!"', GAME_WIDTH / 2, GAME_HEIGHT - 20);
                ctx.textAlign = 'left';
            }
        };

        // ===================================
        // FINAL BOSS: GOLDEN FREDDY
        // ===================================

        GameState.states['FINAL_BOSS'] = {
            player: null,
            boss: null,
            cageX: GAME_WIDTH / 2,
            cageY: 50,

            enter() {
                this.player = GameState.states['LEVEL_5']?.player || new Player(GAME_WIDTH / 2, GAME_HEIGHT - 100);
                this.player.health = this.player.maxHealth; // Full health for final fight
                this.boss = new Boss(GAME_WIDTH / 2 - 16, 200, 100, "GOLDEN FREDDY", 'golden-freddy');
            },

            update(dt) {
                this.player.update(dt);
                this.boss.update(dt, this.player);

                const attackBox = this.player.getAttackBox();
                if (attackBox && this.boss.checkCollision(attackBox)) {
                    if (this.boss.takeDamage(1, this.player.x, this.player.y)) {
                        // Victory!
                        setTimeout(() => {
                            SaveSystem.deleteSave(); // Victory achieved, clear save
                            GameState.setState('VICTORY');
                        }, 2000);
                    }
                }

                this.boss.minions.forEach(minion => {
                    const attackBox = this.player.getAttackBox();
                    if (attackBox && minion.checkCollision(attackBox)) {
                        minion.takeDamage(1, this.player.x, this.player.y);
                    }
                });

                ParticleSystem.update(dt);
            },

            draw(ctx) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Stage curtains
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(0, 0, 100, GAME_HEIGHT);
                ctx.fillRect(GAME_WIDTH - 100, 0, 100, GAME_HEIGHT);

                // Gabby in cage
                ctx.fillStyle = '#444';
                ctx.fillRect(this.cageX - 20, this.cageY, 40, 60);
                ctx.drawImage(Sprites.gabby, this.cageX - 8, this.cageY + 20);

                this.boss.draw(ctx);
                this.player.draw(ctx);
                ParticleSystem.draw(ctx);
                UI.draw(ctx, this.player, 5);
            }
        };

        // ===================================
        // VICTORY CUTSCENE
        // ===================================

        GameState.states['VICTORY'] = {
            scene: 0,
            timer: 0,
            charIndex: 0,
            textTimer: 0,
            hugged: false,
            scenes: [
                { 
                    title: "VICTORY!",
                    text: "Golden Freddy collapses in defeat!",
                    duration: 2500,
                    color: '#FFD700',
                    action: 'defeat'
                },
                { 
                    title: "THE CAGE OPENS",
                    text: "Gabby runs toward Jose...",
                    duration: 3000,
                    color: '#FF69B4',
                    action: 'run'
                },
                {
                    title: "REUNION",
                    text: "Gabby: 'JOSE! You actually did it!'",
                    duration: 3500,
                    color: '#FF1493',
                    action: 'together'
                },
                {
                    title: "REUNION",
                    text: "Jose: 'I told you... nothing can keep us apart.'",
                    duration: 3500,
                    color: '#00FF00',
                    action: 'together'
                },
                {
                    title: "TRUE LOVE",
                    text: "Press SPACE to embrace â¤ï¸",
                    duration: 10000,
                    color: '#FF69B4',
                    action: 'hug_prompt'
                },
                {
                    title: "HAPPILY EVER AFTER",
                    text: "They escape together as the pizzeria crumbles...",
                    duration: 4000,
                    color: '#FFD700',
                    action: 'escape'
                },
                {
                    title: "THE END",
                    text: "TRUE LOVE CONQUERS ALL FEARS",
                    duration: 4000,
                    color: '#FF1493',
                    action: 'end'
                },
                {
                    title: "A MESSAGE FOR GABBY",
                    text: "",
                    duration: 99999,
                    color: '#FF69B4',
                    action: 'message'
                }
            ],

            enter() {
                this.scene = 0;
                this.timer = 0;
                this.charIndex = 0;
                this.textTimer = 0;
                this.hugged = false;
                Audio.playMusic('victory');
            },

            update(dt) {
                this.timer += dt;
                this.textTimer += dt;
                
                const currentScene = this.scenes[this.scene];
                
                // Typing effect
                if (this.charIndex < currentScene.text.length && this.textTimer >= 50) {
                    this.charIndex++;
                    this.textTimer = 0;
                    if (this.charIndex % 2 === 0 && currentScene.text.length > 0) {
                        Audio.playSound('pickup', 0.3);
                    }
                }
                
                // Special handling for hug prompt
                if (currentScene.action === 'hug_prompt' && !this.hugged) {
                    if (Input.keys[' '] || Input.keys['enter']) {
                        this.hugged = true;
                        Audio.playSound('sword'); // Triumphant sound
                        // Create heart particles
                        for (let i = 0; i < 30; i++) {
                            ParticleSystem.createHeal(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);
                        }
                        setTimeout(() => {
                            this.scene++;
                            this.timer = 0;
                            this.charIndex = 0;
                            this.textTimer = 0;
                        }, 2000);
                    }
                    return;
                }

                if (this.timer >= currentScene.duration && this.charIndex >= currentScene.text.length) {
                    if (this.scene < this.scenes.length - 1) {
                        this.scene++;
                        this.timer = 0;
                        this.charIndex = 0;
                        this.textTimer = 0;
                    } else if (currentScene.action === 'message') {
                        // Stay on message, allow return to menu
                        if (Input.keys['enter'] || Input.keys[' ']) {
                            GameState.setState('MENU');
                        }
                    }
                }
            },

            draw(ctx) {
                // Gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
                gradient.addColorStop(0, '#0a0a1a');
                gradient.addColorStop(1, '#1a0a1a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                const currentScene = this.scenes[this.scene];
                
                // Animated stars
                for (let i = 0; i < 100; i++) {
                    const x = (i * 137.5 + this.timer / 10) % GAME_WIDTH;
                    const y = (i * 217.3) % GAME_HEIGHT;
                    const twinkle = Math.sin(this.timer / 100 + i) > 0.5;
                    if (twinkle) {
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(x, y, 2, 2);
                    }
                }

                // Scene-specific visuals
                if (currentScene.action === 'defeat') {
                    // Golden Freddy defeated
                    ctx.fillStyle = '#DAA520';
                    ctx.globalAlpha = 0.5 - (this.timer / currentScene.duration) * 0.5;
                    ctx.fillRect(GAME_WIDTH / 2 - 50, GAME_HEIGHT / 2 - 50, 100, 100);
                    ctx.globalAlpha = 1;
                    // Sparks
                    for (let i = 0; i < 10; i++) {
                        const angle = (this.timer + i * 36) * Math.PI / 180;
                        const radius = this.timer / 10;
                        ctx.fillStyle = i % 2 === 0 ? '#FFD700' : '#FF0000';
                        ctx.fillRect(
                            GAME_WIDTH / 2 + Math.cos(angle) * radius,
                            GAME_HEIGHT / 2 + Math.sin(angle) * radius,
                            4, 4
                        );
                    }
                } else if (currentScene.action === 'together' || currentScene.action === 'hug_prompt') {
                    // Jose and Gabby together
                    const joseX = GAME_WIDTH / 2 - 50;
                    const gabbyX = GAME_WIDTH / 2 + 20;
                    const y = GAME_HEIGHT / 2 - 60;
                    
                    ctx.drawImage(Sprites.jose.down[0], joseX, y, 48, 48);
                    ctx.drawImage(Sprites.gabby, gabbyX, y, 48, 48);
                    
                    // Floating hearts
                    const numHearts = this.hugged ? 40 : 15;
                    for (let i = 0; i < numHearts; i++) {
                        const angle = (this.timer / 20 + i * (360 / numHearts)) * Math.PI / 180;
                        const radius = 80 + Math.sin(this.timer / 100 + i) * 20;
                        const hx = GAME_WIDTH / 2 + Math.cos(angle) * radius;
                        const hy = GAME_HEIGHT / 2 - 40 + Math.sin(angle) * radius - (this.timer / 50);
                        
                        ctx.fillStyle = i % 3 === 0 ? '#FF1493' : (i % 3 === 1 ? '#FF69B4' : '#FFD700');
                        ctx.font = `${12 + Math.sin(this.timer / 100 + i) * 4}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText('â¤ï¸', hx, hy % GAME_HEIGHT);
                    }
                    
                    if (this.hugged) {
                        // Show embrace animation
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                        ctx.beginPath();
                        ctx.arc(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40, 100, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (currentScene.action === 'escape') {
                    // Silhouettes running
                    ctx.fillStyle = '#000';
                    const runOffset = this.timer / 5;
                    ctx.drawImage(Sprites.jose.down[Math.floor(runOffset / 200) % 2], 200 + runOffset, GAME_HEIGHT / 2, 40, 40);
                    ctx.drawImage(Sprites.gabby, 250 + runOffset, GAME_HEIGHT / 2, 40, 40);
                    
                    // Explosion effects behind
                    for (let i = 0; i < 8; i++) {
                        const ex = Math.random() * GAME_WIDTH;
                        const ey = Math.random() * GAME_HEIGHT;
                        const size = Math.random() * 30 + 10;
                        ctx.fillStyle = `rgba(255, ${Math.random() * 100}, 0, ${Math.random() * 0.5})`;
                        ctx.fillRect(ex, ey, size, size);
                    }
                } else if (currentScene.action === 'message') {
                    // Personal message to Gabby
                    const messages = [
                        "To Gabby,",
                        "My Princess Zelda,",
                        "",
                        "Thank you for being my greatest adventure.",
                        "Every level I'd cross, every boss I'd face,",
                        "because a life with you is my greatest treasure.",
                        "",
                        "You make every day feel like a quest worth taking,",
                        "every challenge worth facing,",
                        "every moment worth living.",
                        "",
                        "I love you more than words can express,",
                        "more than any game could show,",
                        "more than all the pixels in the world.",
                        "",
                        "You are my heart, my joy, my everything.",
                        "",
                        "Love always and forever,",
                        "Jose ðŸ’•",
                        "",
                        "",
                        "Press SPACE to return to menu"
                    ];
                    
                    // Draw heart frame
                    ctx.fillStyle = '#FF1493';
                    ctx.font = '60px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â¤ï¸', GAME_WIDTH / 2, 100);
                    
                    // Draw messages
                    ctx.font = '18px "Courier New"';
                    ctx.fillStyle = '#FFD700';
                    messages.forEach((msg, i) => {
                        if (msg === "") return;
                        const y = 180 + i * 25;
                        
                        if (msg.includes("Gabby") || msg.includes("Jose")) {
                            ctx.fillStyle = '#FF69B4';
                            ctx.font = 'bold 20px "Courier New"';
                        } else if (i >= messages.length - 3) {
                            ctx.fillStyle = '#888';
                            ctx.font = '14px "Courier New"';
                        } else {
                            ctx.fillStyle = '#FFD700';
                            ctx.font = '18px "Courier New"';
                        }
                        
                        ctx.fillText(msg, GAME_WIDTH / 2, y);
                    });
                    
                    // Sparkle effects
                    for (let i = 0; i < 30; i++) {
                        const sx = Math.random() * GAME_WIDTH;
                        const sy = Math.random() * GAME_HEIGHT;
                        const pulse = Math.sin(this.timer / 100 + i) > 0.7;
                        if (pulse) {
                            ctx.fillStyle = i % 2 === 0 ? '#FFD700' : '#FF69B4';
                            ctx.fillRect(sx, sy, 3, 3);
                        }
                    }
                }

                // Title
                ctx.fillStyle = currentScene.color;
                ctx.font = 'bold 32px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText(currentScene.title, GAME_WIDTH / 2, 60);

                // Text box (if not on message screen)
                if (currentScene.action !== 'message' && currentScene.text.length > 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(50, GAME_HEIGHT - 120, GAME_WIDTH - 100, 80);
                    ctx.strokeStyle = currentScene.color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(50, GAME_HEIGHT - 120, GAME_WIDTH - 100, 80);

                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px "Courier New"';
                    ctx.textAlign = 'center';
                    const displayText = currentScene.text.substring(0, this.charIndex);
                    ctx.fillText(displayText, GAME_WIDTH / 2, GAME_HEIGHT - 70);
                    
                    // Cursor
                    if (this.charIndex < currentScene.text.length && Math.floor(this.timer / 300) % 2 === 0) {
                        ctx.fillStyle = currentScene.color;
                        ctx.fillText('â–®', GAME_WIDTH / 2 + ctx.measureText(displayText).width / 2 + 10, GAME_HEIGHT - 70);
                    }
                }

                ctx.textAlign = 'left';
                ParticleSystem.draw(ctx);
            }
        };

        // ===================================
        // GAME LOOP
        // ===================================

        let lastTime = performance.now();
        let accumulator = 0;

        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            accumulator += deltaTime;

            // Fixed timestep updates
            while (accumulator >= FRAME_TIME) {
                Input.update(); // Update input state
                GameState.update(FRAME_TIME);
                
                // Update screen shake
                if (screenShake > 0) {
                    shakeX = (Math.random() - 0.5) * screenShake;
                    shakeY = (Math.random() - 0.5) * screenShake;
                    screenShake *= 0.9;
                    if (screenShake < 0.5) screenShake = 0;
                } else {
                    shakeX = 0;
                    shakeY = 0;
                }
                
                accumulator -= FRAME_TIME;
            }

            // Scale context to match game resolution
            ctx.save();
            const scaleX = canvas.width / GAME_WIDTH;
            const scaleY = canvas.height / GAME_HEIGHT;
            ctx.scale(scaleX, scaleY);
            
            // Apply screen shake
            ctx.translate(shakeX, shakeY);

            // Clear and draw
            ctx.fillStyle = '#000';
            ctx.fillRect(-shakeX, -shakeY, GAME_WIDTH, GAME_HEIGHT);
            GameState.draw(ctx);

            ctx.restore();
        }

        // ===================================
        // INITIALIZATION
        // ===================================

        function init() {
            Input.init();
            Audio.init();
            GameState.setState('MENU');
            requestAnimationFrame(gameLoop);
        }

        // Start game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
